<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exosubmoon Preview</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #0a0e17;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        #simulation-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.4) 70%, transparent 100%);
            color: white;
            z-index: 10;
            pointer-events: none;
            text-align: left;
        }
        
        .preview-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
            color: #3498db;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        .preview-subtitle {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .glow-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(52, 152, 219, 0.1), transparent 70%);
            pointer-events: none;
            z-index: 5;
        }
        
        .badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
            animation: pulse 2s infinite;
        }
        
        .click-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 10;
            display: flex;
            align-items: center;
            animation: bounce 2s ease infinite;
        }
        
        .click-hint i {
            margin-left: 5px;
            font-size: 1rem;
        }
        
        .status-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            color: #2ecc71;
            font-size: 0.8rem;
            z-index: 10;
            text-shadow: 0 0 5px rgba(46, 204, 113, 0.5);
        }
        
        .indicator-dot {
            width: 10px;
            height: 10px;
            background-color: #2ecc71;
            border-radius: 50%;
            margin-right: 8px;
            box-shadow: 0 0 8px rgba(46, 204, 113, 0.8);
            animation: blink 1.5s ease infinite;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        
        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
        }
        
        @keyframes blink {
            0% {
                opacity: 0.4;
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0.4;
            }
        }
        
        /* Add Font Awesome for icons */
        .fa {
            display: inline-block;
            width: 1em;
            height: 1em;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        .fa-expand {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512'%3E%3Cpath fill='%23ffffff' d='M0 180V56c0-13.3 10.7-24 24-24h124c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12H64v84c0 6.6-5.4 12-12 12H12c-6.6 0-12-5.4-12-12zM288 44v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12V56c0-13.3-10.7-24-24-24H300c-6.6 0-12 5.4-12 12zm148 276h-40c-6.6 0-12 5.4-12 12v84h-84c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24V332c0-6.6-5.4-12-12-12zM160 468v-40c0-6.6-5.4-12-12-12H64v-84c0-6.6-5.4-12-12-12H12c-6.6 0-12 5.4-12 12v124c0 13.3 10.7 24 24 24h124c6.6 0 12-5.4 12-12z'/%3E%3C/svg%3E");
        }
        
        .fa-circle {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cpath fill='%232ecc71' d='M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8z'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>
    <div id="simulation-container">
        <div class="status-indicator">
            <div class="indicator-dot"></div>
            <span>Live Preview</span>
        </div>
        
        <div class="badge">Interactive</div>
        
        <div class="preview-overlay">
            <div class="preview-title">Exosubmoon Stability Visualization</div>
            <div class="preview-subtitle">Explore the physics of submoon stability in exoplanetary systems</div>
        </div>
        
        <div class="click-hint">
            Click for full simulation <i class="fa fa-expand"></i>
        </div>
        
        <div class="glow-effect"></div>
    </div>
    
    <script>
        // Enhanced preview simulation
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0e17);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('simulation-container').appendChild(renderer.domElement);
        
        // Create starfield background
        const createStarField = (count) => {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                transparent: true,
                opacity: 0.8,
                vertexColors: true
            });
            
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            
            for (let i = 0; i < count; i++) {
                // Random position in sphere
                const radius = 500;
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                positions.push(x, y, z);
                
                // Random star color (white to blue-ish)
                const r = 0.7 + 0.3 * Math.random();
                const g = 0.7 + 0.3 * Math.random();
                const b = 0.9 + 0.1 * Math.random();
                
                color.setRGB(r, g, b);
                colors.push(color.r, color.g, color.b);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        };
        
        // Create galaxy background effect
        const createGalaxyBackground = () => {
            const galaxyGeometry = new THREE.BufferGeometry();
            const galaxyMaterial = new THREE.PointsMaterial({
                size: 1.8,
                color: 0x3498db,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            
            const positions = [];
            
            const galaxyRadius = 100;
            const galaxyParticles = 1000;
            const galaxyArms = 4;
            const armWidth = 0.5;
            
            for (let i = 0; i < galaxyParticles; i++) {
                const radius = Math.random() * galaxyRadius;
                const spinFactor = 4 + Math.random();
                
                // Get a random angle but make it more likely to follow an arm path
                const armAngle = (i % galaxyArms) * (2 * Math.PI / galaxyArms);
                const randomAngle = (Math.random() - 0.5) * armWidth;
                const angle = armAngle + radius * 0.01 * spinFactor + randomAngle;
                
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                const y = (Math.random() - 0.5) * 8;
                
                positions.push(x, y, z);
            }
            
            galaxyGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
            scene.add(galaxy);
            
            // Return the galaxy for animation
            return galaxy;
        };
        
        // Add ambient light for better visibility
        const ambientLight = new THREE.AmbientLight(0x202020, 1);
        scene.add(ambientLight);
        
        // Create Star (central body)
        const createStar = () => {
            // Create star glow
            const starGlowGeometry = new THREE.SphereGeometry(7, 32, 32);
            const starGlowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffee66,
                transparent: true,
                opacity: 0.15,
            });
            const starGlow = new THREE.Mesh(starGlowGeometry, starGlowMaterial);
            scene.add(starGlow);
            
            // Create star core
            const starGeometry = new THREE.SphereGeometry(5, 64, 64);
            const starMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffaa
            });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(star);
            
            // Add flickering light effect
            const flickerLight = new THREE.PointLight(0xffffaa, 1.5, 200, 2);
            flickerLight.position.set(0, 0, 0);
            scene.add(flickerLight);
            
            return [star, starGlow, flickerLight];
        };
        
        // Create texture for gas giant planets
        const createGasGiantTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            
            // Jupiter-like
            grd.addColorStop(0, '#b07f35');
            grd.addColorStop(0.3, '#c8a458');
            grd.addColorStop(0.7, '#e5cea2');
            grd.addColorStop(1, '#b98b45');
            
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bands
            const bandCount = 12;
            for (let i = 0; i < bandCount; i++) {
                const y = (i / bandCount) * canvas.height;
                const height = canvas.height / bandCount * (0.5 + Math.random() * 0.5);
                
                ctx.fillStyle = `rgba(${50 + Math.random() * 100}, ${40 + Math.random() * 60}, ${20 + Math.random() * 40}, ${0.1 + Math.random() * 0.3})`;
                ctx.fillRect(0, y, canvas.width, height);
            }
            
            // Add some storms/spots
            const spotCount = 8;
            for (let i = 0; i < spotCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 5 + Math.random() * 20;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${180 + Math.random() * 75}, ${160 + Math.random() * 70}, ${100 + Math.random() * 50}, ${0.2 + Math.random() * 0.4})`;
                ctx.fill();
            }
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = -1; // Flip texture horizontally
            
            return texture;
        };
        
        // Create texture for rocky body
        const createRockyTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Create base color (Moon-like gray)
            const baseColor = {r: 180, g: 180, b: 180};
            
            ctx.fillStyle = `rgb(${baseColor.r}, ${baseColor.g}, ${baseColor.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add noise for texture
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.random() * 30 - 15;
                
                data[i] = Math.max(0, Math.min(255, baseColor.r + noise));
                data[i+1] = Math.max(0, Math.min(255, baseColor.g + noise));
                data[i+2] = Math.max(0, Math.min(255, baseColor.b + noise));
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Add craters
            const craterCount = 30;
            for (let i = 0; i < craterCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 2 + Math.random() * 15;
                
                // Crater rim
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${baseColor.r + 30}, ${baseColor.g + 30}, ${baseColor.b + 30}, 0.8)`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Crater center (shadow)
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${baseColor.r - 40}, ${baseColor.g - 40}, ${baseColor.b - 40}, 0.7)`;
                ctx.fill();
            }
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = -1; // Flip texture horizontally
            
            return texture;
        };
        
        // Create celestial bodies
        createStarField(1000);
        const galaxy = createGalaxyBackground();
        const [star, starGlow, flickerLight] = createStar();
        
        // Create Planet
        const planetTexture = createGasGiantTexture();
        const planetGeometry = new THREE.SphereGeometry(3, 64, 64);
        const planetMaterial = new THREE.MeshPhongMaterial({ 
            map: planetTexture,
            specular: 0x333333,
            shininess: 30,
            bumpScale: 0.5
        });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        scene.add(planet);
        
        // Add subtle glow to planet
        const planetGlowGeometry = new THREE.SphereGeometry(3.2, 32, 32);
        const planetGlowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x3498db,
            transparent: true,
            opacity: 0.1
        });
        const planetGlow = new THREE.Mesh(planetGlowGeometry, planetGlowMaterial);
        scene.add(planetGlow);
        
        // Create Moon
        const moonTexture = createRockyTexture();
        const moonGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const moonMaterial = new THREE.MeshPhongMaterial({ 
            map: moonTexture,
            specular: 0x333333,
            shininess: 20
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        scene.add(moon);
        
        // Create Submoon
        const submoonGeometry = new THREE.SphereGeometry(0.3, 24, 24);
        const submoonMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xe74c3c,
            specular: 0x222222,
            shininess: 15
        });
        const submoon = new THREE.Mesh(submoonGeometry, submoonMaterial);
        scene.add(submoon);
        
        // Create Orbits with better visuals
        const createOrbit = (radius, color, segments = 128) => {
            const orbitCurve = new THREE.EllipseCurve(
                0, 0,             // Center x, y
                radius, radius,   // X radius, Y radius
                0, 2 * Math.PI,   // Start angle, end angle
                false,            // Clockwise
                0                 // Rotation
            );
            
            const orbitPoints = orbitCurve.getPoints(segments);
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            
            const orbitMaterial = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.4,
                linewidth: 1
            });
            
            return new THREE.Line(orbitGeometry, orbitMaterial);
        };
        
        const planetOrbit = createOrbit(25, 0x3498db);
        planetOrbit.rotation.x = Math.PI / 2;
        scene.add(planetOrbit);
        
        const moonOrbit = createOrbit(6, 0xecf0f1);
        moonOrbit.rotation.x = Math.PI / 2;
        scene.add(moonOrbit);
        
        const submoonOrbit = createOrbit(1.5, 0xe74c3c);
        submoonOrbit.rotation.x = Math.PI / 2;
        scene.add(submoonOrbit);
        
        // Add stability indicator ring
        const stabilityRingGeometry = new THREE.RingGeometry(1.3, 1.7, 64);
        const stabilityRingMaterial = new THREE.MeshBasicMaterial({
            color: 0x2ecc71,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.2
        });
        const stabilityRing = new THREE.Mesh(stabilityRingGeometry, stabilityRingMaterial);
        stabilityRing.rotation.x = Math.PI / 2;
        scene.add(stabilityRing);
        
        // Set initial camera position
        camera.position.set(30, 20, 30);
        camera.lookAt(0, 0, 0);
        
        // Animation variables
        let planetAngle = 0;
        let moonAngle = 0;
        let submoonAngle = 0;
        
        // Animation speeds
        const planetSpeed = 0.001;
        const moonSpeed = 0.003;
        const submoonSpeed = 0.008;
        
        // Set initial positions
        planet.position.set(25, 0, 0);
        planetGlow.position.copy(planet.position);
        moon.position.set(25 + 6, 0, 0);
        moonOrbit.position.copy(planet.position);
        submoon.position.set(25 + 6 + 1.5, 0, 0);
        submoonOrbit.position.copy(moon.position);
        stabilityRing.position.copy(moon.position);
        
        // Add flickering effect to star
        function updateStarFlicker() {
            const flicker = 0.9 + Math.random() * 0.2;
            flickerLight.intensity = 1.5 * flicker;
            
            // Subtle color variation
            const hue = 0.12 + Math.random() * 0.02; // Slight variation in yellow/orange
            const saturation = 0.8 + Math.random() * 0.2;
            const color = new THREE.Color().setHSL(hue, saturation, 0.6);
            flickerLight.color = color;
        }
        
        // Camera auto-rotation
        let cameraAngle = 0;
        
        // Create particles for thruster effect
        function createThrusterParticles() {
            const particleCount = 20;
            const particles = [];
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({
                        color: 0xe74c3c, 
                        transparent: true, 
                        opacity: 0.8
                    })
                );
                
                // Set initial properties
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.05
                    ),
                    age: 0,
                    maxAge: 20 + Math.random() * 20
                };
                
                scene.add(particle);
                particles.push(particle);
            }
            
            return particles;
        }
        
        const thrusterParticles = createThrusterParticles();
        
        // Update particles
        function updateThrusterParticles() {
            thrusterParticles.forEach(particle => {
                // Check if the particle needs resetting
                if (particle.userData.age >= particle.userData.maxAge) {
                    // Reset position to submoon
                    particle.position.copy(submoon.position);
                    
                    // Reset properties
                    particle.userData.age = 0;
                    particle.userData.maxAge = 20 + Math.random() * 20;
                    particle.material.opacity = 0.8;
                    particle.scale.set(1, 1, 1);
                    
                    // Set new velocity (away from moon)
                    const direction = new THREE.Vector3().subVectors(submoon.position, moon.position).normalize();
                    particle.userData.velocity = new THREE.Vector3(
                        direction.x * 0.05 + (Math.random() - 0.5) * 0.02,
                        direction.y * 0.05 + (Math.random() - 0.5) * 0.02,
                        direction.z * 0.05 + (Math.random() - 0.5) * 0.02
                    );
                }
                
                // Update position
                particle.position.add(particle.userData.velocity);
                
                // Age the particle
                particle.userData.age++;
                
                // Fade out as it ages
                particle.material.opacity = 0.8 * (1 - particle.userData.age / particle.userData.maxAge);
                
                // Shrink as it ages
                const scale = 1 - 0.8 * (particle.userData.age / particle.userData.maxAge);
                particle.scale.set(scale, scale, scale);
            });
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the galaxy slowly for dramatic effect
            galaxy.rotation.y += 0.0002;
            galaxy.rotation.x = Math.sin(Date.now() * 0.0001) * 0.1;
            
            // Update star flicker effect once in a while
            if (Math.random() > 0.95) {
                updateStarFlicker();
            }
            
            // Update angles
            planetAngle += planetSpeed;
            moonAngle += moonSpeed;
            submoonAngle += submoonSpeed;
            
            // Update planet position
            planet.position.x = 25 * Math.cos(planetAngle);
            planet.position.z = 25 * Math.sin(planetAngle);
            planetGlow.position.copy(planet.position);
            planet.rotation.y += 0.005;
            
            // Update moon position and orbit
            moonOrbit.position.copy(planet.position);
            moon.position.x = planet.position.x + 6 * Math.cos(moonAngle);
            moon.position.z = planet.position.z + 6 * Math.sin(moonAngle);
            moon.rotation.y += 0.01;
            
            // Update submoon position and orbit
            submoonOrbit.position.copy(moon.position);
            stabilityRing.position.copy(moon.position);
            submoon.position.x = moon.position.x + 1.5 * Math.cos(submoonAngle);
            submoon.position.z = moon.position.z + 1.5 * Math.sin(submoonAngle);
            submoon.rotation.y += 0.015;
            
            // Update thruster particles
            updateThrusterParticles();
            
            // Slowly rotate camera for cinematic effect
            cameraAngle += 0.001;
            const radius = 50;
            camera.position.x = radius * Math.cos(cameraAngle);
            camera.position.z = radius * Math.sin(cameraAngle);
            camera.position.y = 20 + Math.sin(cameraAngle * 2) * 10;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        
        // Start animation
        animate();
        
        // Make the preview clickable to simulate opening the modal
        document.getElementById('simulation-container').addEventListener('click', function() {
            // This would normally open the modal, but in the preview we'll just
            // add a visual feedback effect
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.15)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '20';
            overlay.style.transition = 'opacity 0.5s ease';
            overlay.style.opacity = '0';
            
            document.getElementById('simulation-container').appendChild(overlay);
            
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 10);
            
            setTimeout(() => {
                overlay.style.opacity = '0';
            }, 300);
            
            setTimeout(() => {
                overlay.remove();
            }, 800);
            
            const text = document.createElement('div');
            text.textContent = 'Opening Full Simulation...';
            text.style.color = 'white';
            text.style.fontSize = '1.2rem';
            text.style.padding = '10px 20px';
            text.style.background = 'rgba(52, 152, 219, 0.7)';
            text.style.borderRadius = '5px';
            text.style.boxShadow = '0 0 20px rgba(52, 152, 219, 0.5)';
            text.style.position = 'absolute';
            text.style.top = '50%';
            text.style.left = '50%';
            text.style.transform = 'translate(-50%, -50%)';
            text.style.zIndex = '30';
            text.style.opacity = '0';
            text.style.transition = 'opacity 0.3s ease';
            
            document.getElementById('simulation-container').appendChild(text);
            
            setTimeout(() => {
                text.style.opacity = '1';
            }, 300);
            
            setTimeout(() => {
                text.style.opacity = '0';
            }, 1500);
            
            setTimeout(() => {
                text.remove();
            }, 2000);
        });
    </script>
</body>
</html>