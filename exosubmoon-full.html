<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exosubmoon Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Fixed OrbitControls path -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            background-color: #0f172a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100%;
        }
        
        #root {
            height: 100%;
        }
        
        .simulation-container {
            height: 100%;
            width: 100%;
            position: relative;
        }
        
        .controls-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(15, 23, 42, 0.8);
            padding: 1rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            z-index: 100;
            transition: transform 0.3s ease;
            transform: translateY(70%);
        }
        
        .controls-panel:hover,
        .controls-panel.expanded {
            transform: translateY(0);
        }
        
        .controls-handle {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(15, 23, 42, 0.8);
            color: white;
            padding: 5px 20px;
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            backdrop-filter: blur(10px);
        }
        
        .stats-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(15, 23, 42, 0.8);
            padding: 1rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 350px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(15, 23, 42, 0.9);
            color: white;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            z-index: 1000;
            display: none;
            max-width: 200px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <div id="tooltip" class="tooltip"></div>
    
    <script type="text/babel">
        const ExoSubmoonVisualization = () => {
            const containerRef = React.useRef(null);
            const rendererRef = React.useRef(null);
            const sceneRef = React.useRef(null);
            const cameraRef = React.useRef(null);
            const controlsRef = React.useRef(null);
            const animationRef = React.useRef(null);
            const starFieldRef = React.useRef(null);
            
            // State management
            const [isPlaying, setIsPlaying] = React.useState(true);
            const [speedMultiplier, setSpeedMultiplier] = React.useState(1);
            const [showOrbits, setShowOrbits] = React.useState(true);
            const [showStabilityZones, setShowStabilityZones] = React.useState(true);
            const [viewMode, setViewMode] = React.useState('standard');
            const [presetMode, setPresetMode] = React.useState('optimal');
            const [isPanelExpanded, setIsPanelExpanded] = React.useState(false);
            
            // System parameters
            const [planetMass, setPlanetMass] = React.useState(25);
            const [moonMass, setMoonMass] = React.useState(0.5);
            const [submoonMass, setSubmoonMass] = React.useState(0.08);
            const [planetRadius, setPlanetRadius] = React.useState(20);
            const [moonRadius, setMoonRadius] = React.useState(3.2);
            const [submoonRadius, setSubmoonRadius] = React.useState(0.5);
            
            // Derived values
            const [planetToMoonRatio, setPlanetToMoonRatio] = React.useState(50);
            const [moonToSubmoonRatio, setMoonToSubmoonRatio] = React.useState(6.25);
            const [hillRadiusMoon, setHillRadiusMoon] = React.useState(0);
            const [hillRadiusSubmoon, setHillRadiusSubmoon] = React.useState(0);
            const [rocheLimit, setRocheLimit] = React.useState(0);
            
            // Stats for display
            const [stats, setStats] = React.useState({
                stability: 'High',
                estimatedLifetime: '> 100 million years',
                tidalForces: 'Weak',
                orbitRatio: '0.16',
                stabilityScore: 85,
                criticalParams: []
            });
            
            // Set preset configurations
            React.useEffect(() => {
                if (presetMode === 'optimal') {
                    // Based on research: planet/moon ratio < 60, moon/submoon ratio > 5
                    setPlanetMass(25);
                    setMoonMass(0.5);
                    setSubmoonMass(0.08);
                    setPlanetRadius(20);
                    setMoonRadius(3.2);
                    setSubmoonRadius(0.5);
                } else if (presetMode === 'unstable') {
                    // Unstable configuration: high planet/moon ratio, low moon/submoon ratio
                    setPlanetMass(50);
                    setMoonMass(0.2);
                    setSubmoonMass(0.15);
                    setPlanetRadius(15);
                    setMoonRadius(4.5);
                    setSubmoonRadius(1.2);
                }
            }, [presetMode]);
            
            // Create starfield background
            const createStarField = (scene, count) => {
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1,
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true
                });
                
                const positions = [];
                const colors = [];
                const color = new THREE.Color();
                
                for (let i = 0; i < count; i++) {
                    // Random position in sphere
                    const radius = 1000;
                    const theta = 2 * Math.PI * Math.random();
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    positions.push(x, y, z);
                    
                    // Random star color (white to blue-ish)
                    const r = 0.7 + 0.3 * Math.random();
                    const g = 0.7 + 0.3 * Math.random();
                    const b = 0.9 + 0.1 * Math.random();
                    
                    color.setRGB(r, g, b);
                    colors.push(color.r, color.g, color.b);
                }
                
                starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
                return starField;
            };
            
            // Create texture for gas giant planets
            const createGasGiantTexture = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Create gradient background
                const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
                
                // Jupiter-like
                grd.addColorStop(0, '#b07f35');
                grd.addColorStop(0.3, '#c8a458');
                grd.addColorStop(0.7, '#e5cea2');
                grd.addColorStop(1, '#b98b45');
                
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw bands
                const bandCount = 12;
                for (let i = 0; i < bandCount; i++) {
                    const y = (i / bandCount) * canvas.height;
                    const height = canvas.height / bandCount * (0.5 + Math.random() * 0.5);
                    
                    ctx.fillStyle = `rgba(${50 + Math.random() * 100}, ${40 + Math.random() * 60}, ${20 + Math.random() * 40}, ${0.1 + Math.random() * 0.3})`;
                    ctx.fillRect(0, y, canvas.width, height);
                }
                
                // Add some storms/spots
                const spotCount = 8;
                for (let i = 0; i < spotCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = 5 + Math.random() * 20;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${180 + Math.random() * 75}, ${160 + Math.random() * 70}, ${100 + Math.random() * 50}, ${0.2 + Math.random() * 0.4})`;
                    ctx.fill();
                }
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.repeat.x = -1; // Flip texture horizontally
                
                return texture;
            };
            
            // Create texture for rocky body
            const createRockyTexture = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Create base color (Moon-like gray)
                const baseColor = {r: 180, g: 180, b: 180};
                
                ctx.fillStyle = `rgb(${baseColor.r}, ${baseColor.g}, ${baseColor.b})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add noise for texture
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const noise = Math.random() * 30 - 15;
                    
                    data[i] = Math.max(0, Math.min(255, baseColor.r + noise));
                    data[i+1] = Math.max(0, Math.min(255, baseColor.g + noise));
                    data[i+2] = Math.max(0, Math.min(255, baseColor.b + noise));
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // Add craters
                const craterCount = 30;
                for (let i = 0; i < craterCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const radius = 2 + Math.random() * 15;
                    
                    // Crater rim
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${baseColor.r + 30}, ${baseColor.g + 30}, ${baseColor.b + 30}, 0.8)`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    // Crater center (shadow)
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${baseColor.r - 40}, ${baseColor.g - 40}, ${baseColor.b - 40}, 0.7)`;
                    ctx.fill();
                }
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.repeat.x = -1; // Flip texture horizontally
                
                return texture;
            };
            
            // Calculate stability metrics for the system
            const calculateStabilityMetrics = () => {
                // Calculate the key ratios found in research
                const planetToMoonMassRatio = planetMass / moonMass;
                setPlanetToMoonRatio(planetToMoonMassRatio);
                
                const moonToSubmoonMassRatio = moonMass / submoonMass;
                setMoonToSubmoonRatio(moonToSubmoonMassRatio);
                
                // Calculate orbital ratios
                const moonOrbitRatio = moonRadius / 0.5; // Compare to optimal 0.5 Hill radius
                const submoonOrbitRatio = submoonRadius / 0.5; // Compare to optimal 0.5 Hill radius
                
                // Stability thresholds from research
                const isStable = moonToSubmoonMassRatio > 5 && planetToMoonMassRatio < 60 && 
                                submoonRadius >= 0.3 && submoonRadius <= 0.7;
                                
                const isMarginal = moonToSubmoonMassRatio > 3 && planetToMoonMassRatio < 80 &&
                                submoonRadius >= 0.2 && submoonRadius <= 0.8;
                
                // Calculate a stability score (0-100)
                let stabilityScore = 0;
                
                // Score based on mass ratios (max 70 points)
                let massRatioScore = 0;
                if (planetToMoonMassRatio < 40) massRatioScore += 30;
                else if (planetToMoonMassRatio < 60) massRatioScore += 20;
                else if (planetToMoonMassRatio < 80) massRatioScore += 10;
                
                if (moonToSubmoonMassRatio > 8) massRatioScore += 40;
                else if (moonToSubmoonMassRatio > 5) massRatioScore += 30;
                else if (moonToSubmoonMassRatio > 3) massRatioScore += 15;
                
                // Score based on orbital positions (max 30 points)
                let orbitalScore = 0;
                
                if (submoonRadius >= 0.4 && submoonRadius <= 0.6) orbitalScore += 30;
                else if (submoonRadius >= 0.3 && submoonRadius <= 0.7) orbitalScore += 20;
                else if (submoonRadius >= 0.2 && submoonRadius <= 0.8) orbitalScore += 10;
                
                stabilityScore = massRatioScore + orbitalScore;
                
                // Calculate estimated lifetime based on stability score
                let estimatedLifetime = '';
                let stability = '';
                let tidalForces = '';
                
                if (stabilityScore >= 80) {
                    estimatedLifetime = '> 100 million years';
                    stability = 'High';
                    tidalForces = 'Weak';
                } else if (stabilityScore >= 50) {
                    estimatedLifetime = '50-100 million years';
                    stability = 'Medium';
                    tidalForces = 'Moderate';
                } else if (stabilityScore >= 30) {
                    estimatedLifetime = '10-50 million years';
                    stability = 'Low';
                    tidalForces = 'Strong';
                } else {
                    estimatedLifetime = '< 10 million years';
                    stability = 'Very Low';
                    tidalForces = 'Extreme';
                }
                
                // Identify critical parameters that affect stability
                const criticalParams = [];
                
                if (planetToMoonMassRatio > 60) {
                    criticalParams.push('Planet/Moon mass ratio too high');
                }
                
                if (moonToSubmoonMassRatio < 5) {
                    criticalParams.push('Moon/Submoon mass ratio too low');
                }
                
                if (submoonRadius < 0.3 || submoonRadius > 0.7) {
                    criticalParams.push('Submoon orbital position suboptimal');
                }
                
                // Update stats
                setStats({
                    stability,
                    estimatedLifetime,
                    tidalForces,
                    orbitRatio: moonOrbitRatio.toFixed(2),
                    stabilityScore,
                    criticalParams
                });
            };
            
            // Create celestial bodies and set up the scene
            const createCelestialBodies = () => {
                if (!sceneRef.current) return;
                
                const scene = sceneRef.current;
                
                // Clear existing objects
                while(scene.children.length > 0) { 
                    scene.remove(scene.children[0]); 
                }
                
                // Add ambient light for better visibility
                const ambientLight = new THREE.AmbientLight(0x101010, 0.8);
                scene.add(ambientLight);
                
                // Create star field
                createStarField(scene, 2000);
                
                // Create Star (central body)
                const starRadius = 5;
                const starGeometry = new THREE.SphereGeometry(starRadius, 64, 64);
                const starMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff80
                });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                scene.add(star);
                
                // Add Point Light to simulate star's light
                const light = new THREE.PointLight(0xffffff, 1.5, 1000);
                light.position.set(0, 0, 0);
                light.castShadow = true;
                scene.add(light);
                
                // Scale factors for visualization
                const visualScale = 2; // General scale factor
                
                // Calculate realistic mass-to-radius relationships
                const calculateRadius = (mass, isGasGiant = false) => {
                    if (isGasGiant || mass > 0.1) {
                        return Math.pow(mass, 0.55) * visualScale;
                    } else {
                        return Math.pow(mass, 0.3) * visualScale * 0.7;
                    }
                };
                
                // Calculate Hill radius
                const calculateHillRadius = (primaryMass, secondaryMass, orbitRadius) => {
                    return orbitRadius * Math.pow(secondaryMass / (3 * primaryMass), 1/3);
                };
                
                // Calculate Roche limit
                const calculateRocheLimit = (primaryRadius, primaryDensity, secondaryDensity) => {
                    return primaryRadius * 2.44 * Math.pow(primaryDensity / secondaryDensity, 1/3);
                };
                
                // Create Planet
                const calculatedPlanetRadius = calculateRadius(planetMass, true);
                const planetVisualRadius = calculatedPlanetRadius;
                const planetGeometry = new THREE.SphereGeometry(planetVisualRadius, 64, 64);
                
                // Create planet texture
                const planetTexture = createGasGiantTexture();
                
                const planetMaterial = new THREE.MeshPhongMaterial({ 
                    map: planetTexture,
                    specular: 0x333333,
                    shininess: 30,
                    bumpScale: 0.5
                });
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.castShadow = true;
                planet.receiveShadow = true;
                scene.add(planet);
                
                // Calculate true planet position in orbit
                const planetOrbitAngle = 0; // Initial angle
                planet.position.x = planetRadius * Math.cos(planetOrbitAngle);
                planet.position.z = planetRadius * Math.sin(planetOrbitAngle);
                
                // Create Moon
                const calculatedMoonRadius = calculateRadius(moonMass, moonMass > 0.1);
                const moonVisualRadius = calculatedMoonRadius;
                const moonGeometry = new THREE.SphereGeometry(moonVisualRadius, 32, 32);
                
                // Create moon texture
                const moonTexture = moonMass > 0.1 ? createGasGiantTexture() : createRockyTexture();
                
                const moonMaterial = new THREE.MeshPhongMaterial({ 
                    map: moonTexture,
                    specular: 0x333333,
                    shininess: 20
                });
                const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.castShadow = true;
                moon.receiveShadow = true;
                scene.add(moon);
                
                // Calculate Hill radius of planet (for moon's orbit)
                const hillRadiusPlanet = calculateHillRadius(1000, planetMass, planetRadius); // Star mass approximated
                setHillRadiusMoon(hillRadiusPlanet);
                
                // Calculate Roche limit for moon around planet
                const planetDensity = 1.33; // Jupiter density in g/cm³
                const moonDensity = moonMass > 0.1 ? 1.33 : 3.9; // g/cm³
                const rocheLimitMoon = calculateRocheLimit(planetVisualRadius, planetDensity, moonDensity);
                setRocheLimit(rocheLimitMoon);
                
                // Place moon in its orbit
                const moonOrbitRadius = moonRadius * hillRadiusPlanet;
                const moonOrbitAngle = 0; // Initial angle
                moon.position.x = planet.position.x + moonOrbitRadius * Math.cos(moonOrbitAngle);
                moon.position.z = planet.position.z + moonOrbitRadius * Math.sin(moonOrbitAngle);
                
                // Create Submoon
                const calculatedSubmoonRadius = calculateRadius(submoonMass, false);
                const submoonVisualRadius = calculatedSubmoonRadius;
                const submoonGeometry = new THREE.SphereGeometry(submoonVisualRadius, 24, 24);
                
                // Create submoon texture (likely rocky for all realistic submoons)
                const submoonTexture = createRockyTexture();
                
                const submoonMaterial = new THREE.MeshPhongMaterial({ 
                    map: submoonTexture,
                    specular: 0x222222,
                    shininess: 15
                });
                const submoon = new THREE.Mesh(submoonGeometry, submoonMaterial);
                submoon.castShadow = true;
                submoon.receiveShadow = true;
                scene.add(submoon);
                
                // Calculate Hill radius of moon (for submoon's orbit)
                const hillRadiusMoonValue = calculateHillRadius(planetMass, moonMass, moonOrbitRadius);
                setHillRadiusSubmoon(hillRadiusMoonValue);
                
                // Place submoon in its orbit
                const submoonOrbitRadius = submoonRadius * hillRadiusMoonValue;
                const submoonOrbitAngle = 0; // Initial angle
                submoon.position.x = moon.position.x + submoonOrbitRadius * Math.cos(submoonOrbitAngle);
                submoon.position.z = moon.position.z + submoonOrbitRadius * Math.sin(submoonOrbitAngle);
                
                // Create Orbits as rings
                if (showOrbits) {
                    // Planet's orbit around star
                    const planetOrbitGeometry = new THREE.RingGeometry(planetRadius - 0.1, planetRadius + 0.1, 128);
                    const planetOrbitMaterial = new THREE.MeshBasicMaterial({
                        color: 0x3498db,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    const planetOrbit = new THREE.Mesh(planetOrbitGeometry, planetOrbitMaterial);
                    planetOrbit.rotation.x = Math.PI / 2;
                    scene.add(planetOrbit);
                    
                    // Moon's orbit around planet
                    const moonOrbitGeometry = new THREE.RingGeometry(moonOrbitRadius - 0.05, moonOrbitRadius + 0.05, 128);
                    const moonOrbitMaterial = new THREE.MeshBasicMaterial({
                        color: 0xecf0f1,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    const moonOrbit = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
                    moonOrbit.rotation.x = Math.PI / 2;
                    moonOrbit.position.copy(planet.position);
                    scene.add(moonOrbit);
                    
                    // Submoon's orbit around moon
                    const submoonOrbitGeometry = new THREE.RingGeometry(submoonOrbitRadius - 0.02, submoonOrbitRadius + 0.02, 64);
                    const submoonOrbitMaterial = new THREE.MeshBasicMaterial({
                        color: 0xe74c3c,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    const submoonOrbit = new THREE.Mesh(submoonOrbitGeometry, submoonOrbitMaterial);
                    submoonOrbit.rotation.x = Math.PI / 2;
                    submoonOrbit.position.copy(moon.position);
                    scene.add(submoonOrbit);
                }
                
                // Add stability zones visualizations if enabled
                if (showStabilityZones) {
                    // Hill sphere boundary for moon
                    const hillSphereGeometry = new THREE.SphereGeometry(hillRadiusPlanet, 32, 32);
                    const hillSphereMaterial = new THREE.MeshBasicMaterial({
                        color: 0x3498db,
                        transparent: true,
                        opacity: 0.05,
                        wireframe: true
                    });
                    const hillSphere = new THREE.Mesh(hillSphereGeometry, hillSphereMaterial);
                    hillSphere.position.copy(planet.position);
                    scene.add(hillSphere);
                    
                    // Roche limit for planet
                    const rocheLimitGeometry = new THREE.SphereGeometry(rocheLimitMoon, 32, 32);
                    const rocheLimitMaterial = new THREE.MeshBasicMaterial({
                        color: 0xe74c3c,
                        transparent: true,
                        opacity: 0.05,
                        wireframe: true
                    });
                    const rocheLimit = new THREE.Mesh(rocheLimitGeometry, rocheLimitMaterial);
                    rocheLimit.position.copy(planet.position);
                    scene.add(rocheLimit);
                    
                    // Optimal moon orbital zone (from research: 0.3-0.5 Hill radius)
                    const optimalOrbitMinRadius = 0.3 * hillRadiusPlanet;
                    const optimalOrbitMaxRadius = 0.5 * hillRadiusPlanet;
                    
                    const optimalOrbitGeometry = new THREE.RingGeometry(optimalOrbitMinRadius, optimalOrbitMaxRadius, 64);
                    const optimalOrbitMaterial = new THREE.MeshBasicMaterial({
                        color: 0x2ecc71,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.2
                    });
                    const optimalOrbit = new THREE.Mesh(optimalOrbitGeometry, optimalOrbitMaterial);
                    optimalOrbit.rotation.x = Math.PI / 2;
                    optimalOrbit.position.copy(planet.position);
                    scene.add(optimalOrbit);
                    
                    // Hill sphere boundary for submoon
                    const hillSphereSubmoonGeometry = new THREE.SphereGeometry(hillRadiusMoonValue, 24, 24);
                    const hillSphereSubmoonMaterial = new THREE.MeshBasicMaterial({
                        color: 0xe74c3c,
                        transparent: true,
                        opacity: 0.05,
                        wireframe: true
                    });
                    const hillSphereSubmoon = new THREE.Mesh(hillSphereSubmoonGeometry, hillSphereSubmoonMaterial);
                    hillSphereSubmoon.position.copy(moon.position);
                    scene.add(hillSphereSubmoon);
                    
                    // Optimal submoon orbital zone (from research: 0.4-0.6 Hill radius)
                    const optimalSubmoonMinRadius = 0.4 * hillRadiusMoonValue;
                    const optimalSubmoonMaxRadius = 0.6 * hillRadiusMoonValue;
                    
                    const optimalSubmoonOrbitGeometry = new THREE.RingGeometry(optimalSubmoonMinRadius, optimalSubmoonMaxRadius, 48);
                    const optimalSubmoonOrbitMaterial = new THREE.MeshBasicMaterial({
                        color: 0x2ecc71,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.2
                    });
                    const optimalSubmoonOrbit = new THREE.Mesh(optimalSubmoonOrbitGeometry, optimalSubmoonOrbitMaterial);
                    optimalSubmoonOrbit.rotation.x = Math.PI / 2;
                    optimalSubmoonOrbit.position.copy(moon.position);
                    scene.add(optimalSubmoonOrbit);
                }
                
                return {
                    star, 
                    planet,
                    moon,
                    submoon,
                    planetPosition: planet.position.clone(),
                    moonPosition: moon.position.clone(),
                    submoonPosition: submoon.position.clone(),
                    moonOrbitRadius,
                    submoonOrbitRadius
                };
            };
            
            // Start animation loop
            const startAnimation = (objects) => {
                if (!cameraRef.current || !rendererRef.current || !sceneRef.current || !controlsRef.current) return;
                
                const camera = cameraRef.current;
                const renderer = rendererRef.current;
                const scene = sceneRef.current;
                const controls = controlsRef.current;
                
                // Variables for animation
                let planetAngle = 0;
                let moonAngle = 0;
                let submoonAngle = 0;
                
                // Calculate orbital periods using Kepler's laws
                // For periods: T² ∝ a³/M where a is semimajor axis and M is central mass
                const keplerConstant = 0.02; // Arbitrary constant for visualization
                
                // Calculate period for planet around star (star is much more massive)
                const planetPeriod = keplerConstant * Math.sqrt(Math.pow(planetRadius, 3));
                
                // Calculate period for moon around planet
                const moonPeriod = keplerConstant * Math.sqrt(Math.pow(objects.moonOrbitRadius, 3) / planetMass);
                
                // Calculate period for submoon around moon
                const submoonPeriod = keplerConstant * Math.sqrt(Math.pow(objects.submoonOrbitRadius, 3) / moonMass);
                
                // Convert periods to angular velocities
                const planetSpeed = (2 * Math.PI) / (planetPeriod * 100);
                const moonSpeed = (2 * Math.PI) / (moonPeriod * 100);
                const submoonSpeed = (2 * Math.PI) / (submoonPeriod * 100);
                
                // Animation loop
                const animate = () => {
                    if (controlsRef.current) controlsRef.current.update();
                    
                    if (isPlaying) {
                        // Update angles based on calculated speeds and speed multiplier
                        planetAngle += planetSpeed * speedMultiplier;
                        moonAngle += moonSpeed * speedMultiplier;
                        submoonAngle += submoonSpeed * speedMultiplier;
                        
                        // Update planet position
                        objects.planet.position.x = planetRadius * Math.cos(planetAngle);
                        objects.planet.position.z = planetRadius * Math.sin(planetAngle);
                        
                        // Add slight wobble to planet rotation to simulate axis tilt
                        objects.planet.rotation.x = Math.sin(planetAngle * 0.5) * 0.1;
                        objects.planet.rotation.y += 0.003 * speedMultiplier;
                        
                        // Update moon position relative to planet
                        objects.moon.position.x = objects.planet.position.x + objects.moonOrbitRadius * Math.cos(moonAngle);
                        objects.moon.position.z = objects.planet.position.z + objects.moonOrbitRadius * Math.sin(moonAngle);
                        objects.moon.rotation.y += 0.005 * speedMultiplier;
                        
                        // Update submoon position relative to moon
                        objects.submoon.position.x = objects.moon.position.x + objects.submoonOrbitRadius * Math.cos(submoonAngle);
                        objects.submoon.position.z = objects.moon.position.z + objects.submoonOrbitRadius * Math.sin(submoonAngle);
                        objects.submoon.rotation.y += 0.007 * speedMultiplier;
                        
                        // Update orbital visualizations
                        scene.children.forEach(child => {
                            // Update moon's orbit position
                            if (child.geometry && child.geometry.type === 'RingGeometry' && 
                                child.material && child.material.color.getHexString() === 'ecf0f1') {
                                child.position.copy(objects.planet.position);
                            }
                            
                            // Update submoon's orbit position
                            if (child.geometry && child.geometry.type === 'RingGeometry' && 
                                child.material && child.material.color.getHexString() === 'e74c3c') {
                                child.position.copy(objects.moon.position);
                            }
                            
                            // Update Hill sphere and stability zone visualizations
                            if (child.geometry && child.geometry.type === 'SphereGeometry' && 
                                child.material && child.material.wireframe) {
                                if (child.material.color.getHexString() === '3498db') {
                                    child.position.copy(objects.planet.position);
                                } else if (child.material.color.getHexString() === 'e74c3c') {
                                    child.position.copy(objects.moon.position);
                                }
                            }
                            
                            // Update optimal orbit zones
                            if (child.geometry && child.geometry.type === 'RingGeometry' && 
                                child.material && child.material.color.getHexString() === '2ecc71') {
                                if (child.scale.x > 2) { // Planet's optimal zone
                                    child.position.copy(objects.planet.position);
                                } else { // Moon's optimal zone
                                    child.position.copy(objects.moon.position);
                                }
                            }
                        });
                    }
                    
                    // Update camera position based on view mode
                    if (viewMode === 'topDown') {
                        // Top-down view
                        camera.position.set(0, 100, 0);
                        camera.lookAt(0, 0, 0);
                        controls.enabled = false;
                    } else if (viewMode === 'planet') {
                        // Follow planet view
                        const offset = new THREE.Vector3(20, 15, 20);
                        camera.position.set(
                            objects.planet.position.x + offset.x,
                            offset.y,
                            objects.planet.position.z + offset.z
                        );
                        camera.lookAt(objects.planet.position);
                        controls.enabled = false;
                    } else if (viewMode === 'moon') {
                        // Follow moon view
                        const offset = new THREE.Vector3(5, 3, 5);
                        camera.position.set(
                            objects.moon.position.x + offset.x,
                            objects.moon.position.y + offset.y,
                            objects.moon.position.z + offset.z
                        );
                        camera.lookAt(objects.moon.position);
                        controls.enabled = false;
                    } else if (viewMode === 'educational') {
                        // Educational view that keeps system in perspective
                        const radius = 80;
                        const angle = planetAngle * 0.1;
                        camera.position.set(
                            radius * Math.cos(angle),
                            40,
                            radius * Math.sin(angle)
                        );
                        camera.lookAt(0, 0, 0);
                        controls.enabled = false;
                    } else {
                        // Standard (free) view
                        controls.enabled = true;
                    }
                    
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(animate);
                };
                
                if (animationRef.current) {
                    cancelAnimationFrame(animationRef.current);
                }
                
                animate();
            };
            
            // Initialize the visualization
            React.useEffect(() => {
                const container = containerRef.current;
                if (!container) return;
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                // Create scene, camera, and renderer
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 2000);
                
                const renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true 
                });
                
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setClearColor(0x0f172a);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(renderer.domElement);
                
                // Add OrbitControls
                const controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.enablePan = false;
                controls.minDistance = 30;
                controls.maxDistance = 200;
                
                sceneRef.current = scene;
                cameraRef.current = camera;
                rendererRef.current = renderer;
                controlsRef.current = controls;
                
                // Set initial camera position
                camera.position.set(60, 40, 60);
                camera.lookAt(0, 0, 0);
                
                // Add window resize handler
                const handleResize = () => {
                    if (!containerRef.current) return;
                    const width = containerRef.current.clientWidth;
                    const height = containerRef.current.clientHeight;
                    
                    if (rendererRef.current && cameraRef.current) {
                        rendererRef.current.setSize(width, height);
                        cameraRef.current.aspect = width / height;
                        cameraRef.current.updateProjectionMatrix();
                    }
                };
                
                window.addEventListener('resize', handleResize);
                
                // Cleanup function
                return () => {
                    window.removeEventListener('resize', handleResize);
                    
                    if (animationRef.current) {
                        cancelAnimationFrame(animationRef.current);
                    }
                    
                    if (rendererRef.current && containerRef.current) {
                        containerRef.current.removeChild(rendererRef.current.domElement);
                        rendererRef.current.dispose();
                    }
                };
            }, []);
            
            // Update celestial bodies and orbits when parameters change
            React.useEffect(() => {
                if (!sceneRef.current) return;
                
                const scene = sceneRef.current;
                
                // Create Solar System objects
                const objects = createCelestialBodies();
                
                // Calculate stability metrics
                calculateStabilityMetrics();
                
                // Start animation
                startAnimation(objects);
                
            }, [planetMass, moonMass, submoonMass, planetRadius, moonRadius, submoonRadius, showOrbits, showStabilityZones]);
            
            // Add tooltip functionality
            const showTooltip = (text, event) => {
                const tooltip = document.getElementById('tooltip');
                if (tooltip) {
                    tooltip.textContent = text;
                    tooltip.style.left = `${event.clientX + 10}px`;
                    tooltip.style.top = `${event.clientY + 10}px`;
                    tooltip.style.display = 'block';
                }
            };
            
            const hideTooltip = () => {
                const tooltip = document.getElementById('tooltip');
                if (tooltip) {
                    tooltip.style.display = 'none';
                }
            };
            
            return (
                <div className="simulation-container">
                    <div ref={containerRef} className="w-full h-full"></div>
                    
                    <div className="stats-panel">
                        <h3 className="text-lg font-bold mb-2">System Stability Analysis</h3>
                        <div className="grid grid-cols-2 gap-2 text-sm">
                            <div>Stability:</div>
                            <div className={`font-bold ${
                                stats.stability === 'High' ? 'text-green-400' : 
                                stats.stability === 'Medium' ? 'text-yellow-400' : 
                                stats.stability === 'Low' ? 'text-orange-400' : 'text-red-400'
                            }`}>
                                {stats.stability}
                            </div>
                            
                            <div>Estimated Lifetime:</div>
                            <div className="font-bold">{stats.estimatedLifetime}</div>
                            
                            <div>Stability Score:</div>
                            <div className={`font-bold ${
                                stats.stabilityScore >= 80 ? 'text-green-400' : 
                                stats.stabilityScore >= 50 ? 'text-yellow-400' : 
                                stats.stabilityScore >= 30 ? 'text-orange-400' : 'text-red-400'
                            }`}>
                                {stats.stabilityScore}/100
                            </div>
                            
                            <div>Planet/Moon Ratio:</div>
                            <div className={`font-bold ${planetToMoonRatio < 60 ? 'text-green-400' : 'text-red-400'}`}>
                                {planetToMoonRatio.toFixed(1)}:1
                            </div>
                            
                            <div>Moon/Submoon Ratio:</div>
                            <div className={`font-bold ${moonToSubmoonRatio > 5 ? 'text-green-400' : 'text-red-400'}`}>
                                {moonToSubmoonRatio.toFixed(1)}:1
                            </div>
                        </div>
                        
                        {stats.criticalParams.length > 0 && (
                            <div className="mt-3 p-2 bg-red-900 bg-opacity-50 rounded">
                                <h4 className="font-bold text-xs uppercase mb-1">Critical Issues:</h4>
                                <ul className="text-xs">
                                    {stats.criticalParams.map((param, index) => (
                                        <li key={index} className="flex items-center">
                                            <span className="text-red-400 mr-1">•</span> {param}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                    
                    <div className={`controls-panel ${isPanelExpanded ? 'expanded' : ''}`}>
                        <div className="controls-handle" onClick={() => setIsPanelExpanded(!isPanelExpanded)}>
                            <i className={`fas fa-chevron-${isPanelExpanded ? 'down' : 'up'} mr-2`}></i>
                            Controls
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            {/* System parameters */}
                            <div className="space-y-3">
                                <h3 className="text-md font-bold text-white mb-2">System Parameters</h3>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm flex justify-between">
                                        <span>Planet Mass: {planetMass} M<sub>jup</sub></span>
                                    </label>
                                    <input
                                        type="range"
                                        min="5"
                                        max="100"
                                        value={planetMass}
                                        onChange={(e) => setPlanetMass(Number(e.target.value))}
                                        className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                                        onMouseOver={(e) => showTooltip('Planet mass affects Hill radius and stability', e)}
                                        onMouseOut={hideTooltip}
                                    />
                                </div>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm flex justify-between">
                                        <span>Moon Mass: {moonMass} M<sub>jup</sub></span>
                                        <span className={`${planetToMoonRatio < 60 ? 'text-green-400' : 'text-red-400'} text-xs`}>
                                            {planetToMoonRatio < 60 ? '✓ Optimal Ratio' : '✗ Too small'}
                                        </span>
                                    </label>
                                    <input
                                        type="range"
                                        min="0.1"
                                        max="10"
                                        step="0.1"
                                        value={moonMass}
                                        onChange={(e) => setMoonMass(Number(e.target.value))}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                        onMouseOver={(e) => showTooltip('Optimal planet/moon mass ratio is <60', e)}
                                        onMouseOut={hideTooltip}
                                    />
                                </div>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm flex justify-between">
                                        <span>Submoon Mass: {submoonMass} M<sub>jup</sub></span>
                                        <span className={`${moonToSubmoonRatio > 5 ? 'text-green-400' : 'text-red-400'} text-xs`}>
                                            {moonToSubmoonRatio > 5 ? '✓ Optimal Ratio' : '✗ Too large'}
                                        </span>
                                    </label>
                                    <input
                                        type="range"
                                        min="0.01"
                                        max="1"
                                        step="0.01"
                                        value={submoonMass}
                                        onChange={(e) => setSubmoonMass(Number(e.target.value))}
                                        className="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
                                        onMouseOver={(e) => showTooltip('Optimal moon/submoon mass ratio is >5', e)}
                                        onMouseOut={hideTooltip}
                                    />
                                </div>
                            </div>
                            
                            {/* Orbital parameters */}
                            <div className="space-y-3">
                                <h3 className="text-md font-bold text-white mb-2">Orbital Parameters</h3>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm">Planet Orbit: {planetRadius} AU</label>
                                    <input
                                        type="range"
                                        min="10"
                                        max="30"
                                        value={planetRadius}
                                        onChange={(e) => setPlanetRadius(Number(e.target.value))}
                                        className="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer"
                                    />
                                </div>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm">Moon Orbit: {moonRadius} Hill radii</label>
                                    <input
                                        type="range"
                                        min="0.1"
                                        max="0.7"
                                        step="0.05"
                                        value={moonRadius}
                                        onChange={(e) => setMoonRadius(Number(e.target.value))}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                        onMouseOver={(e) => showTooltip('Hill radius is the boundary of gravitational influence', e)}
                                        onMouseOut={hideTooltip}
                                    />
                                </div>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-sm flex justify-between">
                                        <span>Submoon Orbit: {submoonRadius} Hill radii</span>
                                        <span className={`${
                                            submoonRadius >= 0.4 && submoonRadius <= 0.6 ? 'text-green-400' : 
                                            submoonRadius >= 0.3 && submoonRadius <= 0.7 ? 'text-yellow-400' : 'text-red-400'
                                        } text-xs`}>
                                            {submoonRadius >= 0.4 && submoonRadius <= 0.6 ? '✓ Optimal Zone' : 'Suboptimal'}
                                        </span>
                                    </label>
                                    <input
                                        type="range"
                                        min="0.1"
                                        max="0.9"
                                        step="0.05"
                                        value={submoonRadius}
                                        onChange={(e) => setSubmoonRadius(Number(e.target.value))}
                                        className="w-full h-2 bg-red-200 rounded-lg appearance-none cursor-pointer"
                                        onMouseOver={(e) => showTooltip('Optimal position: 0.4-0.6 Hill radii', e)}
                                        onMouseOut={hideTooltip}
                                    />
                                </div>
                            </div>
                            
                            {/* Simulation controls */}
                            <div className="space-y-3">
                                <h3 className="text-md font-bold text-white mb-2">Simulation Controls</h3>
                                
                                <div className="flex space-x-2 mb-2">
                                    <button 
                                        onClick={() => setIsPlaying(!isPlaying)}
                                        className="px-3 py-1 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex-1 flex items-center justify-center text-sm"
                                    >
                                        {isPlaying ? 
                                            <span><i className="fas fa-pause mr-1"></i> Pause</span> : 
                                            <span><i className="fas fa-play mr-1"></i> Play</span>
                                        }
                                    </button>
                                    
                                    <button 
                                        onClick={() => setShowOrbits(!showOrbits)}
                                        className="px-3 py-1 bg-gray-600 text-white rounded-lg hover:bg-gray-700 flex-1 flex items-center justify-center text-sm"
                                    >
                                        {showOrbits ? 
                                            <span><i className="fas fa-eye-slash mr-1"></i> Hide Orbits</span> : 
                                            <span><i className="fas fa-eye mr-1"></i> Show Orbits</span>
                                        }
                                    </button>
                                </div>
                                
                                <div className="flex space-x-2 mb-2">
                                    <button 
                                        onClick={() => setShowStabilityZones(!showStabilityZones)}
                                        className={`px-3 py-1 text-sm ${showStabilityZones ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-600 hover:bg-gray-700'} text-white rounded-lg flex-1 flex items-center justify-center`}
                                    >
                                        {showStabilityZones ? 
                                            <span><i className="fas fa-chart-area mr-1"></i> Hide Zones</span> : 
                                            <span><i className="fas fa-chart-area mr-1"></i> Show Zones</span>
                                        }
                                    </button>
                                </div>
                                
                                <div className="grid grid-cols-2 gap-1 mb-2">
                                    <div className="space-y-1">
                                        <label className="text-gray-300 text-xs">Speed: {speedMultiplier}x</label>
                                        <input
                                            type="range"
                                            min="0.1"
                                            max="5"
                                            step="0.1"
                                            value={speedMultiplier}
                                            onChange={(e) => setSpeedMultiplier(Number(e.target.value))}
                                            className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
                                        />
                                    </div>
                                    
                                    <div className="space-y-1">
                                        <label className="text-gray-300 text-xs">View Mode:</label>
                                        <select 
                                            value={viewMode}
                                            onChange={(e) => setViewMode(e.target.value)}
                                            className="w-full bg-gray-700 text-white rounded-lg text-xs p-1"
                                        >
                                            <option value="standard">Free View</option>
                                            <option value="topDown">Top Down</option>
                                            <option value="planet">Planet View</option>
                                            <option value="moon">Moon View</option>
                                            <option value="educational">Educational</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div className="space-y-1">
                                    <label className="text-gray-300 text-xs">Presets:</label>
                                    <div className="grid grid-cols-3 gap-1">
                                        <button 
                                            onClick={() => setPresetMode('optimal')}
                                            className={`px-2 py-1 rounded-lg text-xs ${presetMode === 'optimal' ? 'bg-green-600 text-white' : 'bg-gray-700 text-gray-300'}`}
                                        >
                                            Optimal
                                        </button>
                                        <button 
                                            onClick={() => setPresetMode('unstable')}
                                            className={`px-2 py-1 rounded-lg text-xs ${presetMode === 'unstable' ? 'bg-red-600 text-white' : 'bg-gray-700 text-gray-300'}`}
                                        >
                                            Unstable
                                        </button>
                                        <button 
                                            onClick={() => setPresetMode('custom')}
                                            className={`px-2 py-1 rounded-lg text-xs ${presetMode === 'custom' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-300'}`}
                                        >
                                            Custom
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Render the component
        ReactDOM.render(<ExoSubmoonVisualization />, document.getElementById('root'));
    </script>
</body>
</html>